import {
  ConfigSchemaV35Json,
  Labels,
  ListOfStrings,
  ListOrDict,
} from "@gfi-centre-ouest/docker-compose-spec-typescript/lib/docker-compose-spec-v3.5";
import { DefinitionsService as DefinitionsServiceV35Json } from "@gfi-centre-ouest/docker-compose-spec-typescript/lib/docker-compose-spec-v3.5";
import { writeFile } from "fs";
import { injectable } from "inversify";
import { join } from "path";
import {
  DCConfigFactory,
  DockerComposeDefinitionRepository,
} from "../dockerComposeWriter";
import { ConfigFacade, Service } from "./Config.service";
import * as yaml from "js-yaml";
import { merge } from "lodash";
import { PathResolverService } from "./PathResolver.service";
import { readFile } from "../Utils";

export type DefinitionsService = DefinitionsServiceV35Json;
export type ConfigSchema = ConfigSchemaV35Json;
export type BildSchema =
  | string
  | {
      context?: string;
      dockerfile?: string;
      args?: ListOrDict;
      labels?: Labels;
      cache_from?: ListOfStrings;
      network?: string;
      target?: string;
      shm_size?: number | string;
    };

@injectable()
export class DockerComposeWriterService {
  constructor(
    private configFacade: ConfigFacade,
    private dockerConfig: DockerComposeDefinitionRepository,
    private pathService: PathResolverService
  ) {}

  async dockerComposesRegeneration(_context: any) {
    const operations: Promise<any>[] = [];
    for (
      let index = 0;
      index < this.configFacade.expose().services.length;
      index++
    ) {
      const service = this.configFacade.expose().services[index];
      const dockerComposeDef = this.dockerConfig.make(service.type, {
        ..._context,
        ...service.options,
        ...service,
      });
      const configOverride = (service.dockerCompose || {}) as ConfigSchema;
      const dockerCompose = this.mergeDCConfig(
        dockerComposeDef,
        configOverride
      );
      operations.push(this.writeDockeCompose(dockerCompose, service));
    }
    await Promise.all(operations);
  }

  async autoregisterDCConfigFactory() {
    const dockerGeneratorsMap = JSON.parse(
      (await readFile(this.pathService.dockerGeneratorJsonPath())).toString()
    );
    const listRegistrableServices = Object.keys(dockerGeneratorsMap);
    for (let index = 0; index < listRegistrableServices.length; index++) {
      const type = listRegistrableServices[index];
      if (dockerGeneratorsMap[type]) {
        const factoryModulePath = this.pathService.resolveDockerGenerator(
          dockerGeneratorsMap[type]
        );
        const factoryFunction = (await import(factoryModulePath).then(
          (module) => module.default
        )) as DCConfigFactory;
        this.dockerConfig.register(type, factoryFunction);
      }
    }
  }

  writeDockeCompose(dockerComposeDesc: ConfigSchema, service: Service) {
    return new Promise((res, rej) => {
      const topComment =
        "# This file is autogenerated do not change this file, see workpace.json and the documentation if you want to edit this output";
      const content = `${topComment}
${yaml.safeDump(dockerComposeDesc)}`;
      writeFile(join(process.cwd(), service.dcompose), content, (error) => {
        if (error) {
          rej(error);
        } else {
          res();
        }
      });
    });
  }

  mergeDCConfig(
    dockerComposeOne: ConfigSchema,
    dockerComposeTwo: ConfigSchema
  ): ConfigSchema {
    return merge(dockerComposeOne, dockerComposeTwo);
  }
}

import "reflect-metadata";
import { injectable } from "inversify";
import {
  ConfigSchemaV35Json,
  Labels,
  ListOfStrings,
  ListOrDict,
} from "@gfi-centre-ouest/docker-compose-spec-typescript/lib/docker-compose-spec-v3.5";
import { merge } from "lodash";
import { Service } from "./ConfigurationHelper";
import * as yaml from "js-yaml";
import { writeFile } from "fs";
import { join } from "path";
import dockerGeneratorsMap = require("../../new/src/docker.generator.map.json");
import { ConfigService } from "./injectableServices/Config.service";

export type ConfigSchema = ConfigSchemaV35Json;
export type BildSchema =
  | string
  | {
      context?: string;
      dockerfile?: string;
      args?: ListOrDict;
      labels?: Labels;
      cache_from?: ListOfStrings;
      network?: string;
      target?: string;
      shm_size?: number | string;
    };

export function writeDockeCompose(
  dockerComposeDesc: ConfigSchema,
  service: Service
) {
  return new Promise((res, rej) => {
    const topComment =
      "# This file is autogenerated do not change this file, see workpace.json and the documentation if you want to edit this output";
    const content = `${topComment}
${yaml.safeDump(dockerComposeDesc)}`;
    writeFile(join(process.cwd(), service.dcompose), content, (error) => {
      if (error) {
        rej(error);
      } else {
        res();
      }
    });
  });
}

export async function dockerComposesRegeneration(
  config: ConfigService,
  dockerConfig: DockerComposeDefinitionRepository,
  _context: any
) {
  const operations: Promise<any>[] = [];
  for (let index = 0; index < config.services.length; index++) {
    const service = config.services[index];
    const dockerComposeDef = dockerConfig.make(service.type, {
      ..._context,
      ...service.options,
      ...service,
    });
    const configOverride = (service.dockerCompose || {}) as ConfigSchema;
    const dockerCompose = mergeDCConfig(dockerComposeDef, configOverride);
    operations.push(writeDockeCompose(dockerCompose, service));
  }
  await Promise.all(operations);
}

export function mergeDCConfig(
  dockerComposeOne: ConfigSchema,
  dockerComposeTwo: ConfigSchema
): ConfigSchema {
  return merge(dockerComposeOne, dockerComposeTwo);
}

export type DCConfigFactory<T = any> = (context: T) => ConfigSchema;

@injectable()
export class DockerComposeDefinitionRepository {
  private map = new Map<string, DCConfigFactory>();

  register(type: string, dcFunction: DCConfigFactory) {
    if (!this.map.has(type)) {
      this.map.set(type, dcFunction);
    } else {
      throw new DCConfigFactoryAlreadyRegisteredError(type);
    }
  }

  make<T>(type: string, context?: T): ConfigSchema {
    if (this.map.has(type)) {
      const factory = this.map.get(type)!;
      return factory(context);
    } else {
      throw new DCConfigFactoryNotRegisteredError(type);
    }
  }
}

export class DCConfigFactoryAlreadyRegisteredError extends Error {
  constructor(type: string) {
    super(
      `The service ${type} has already declared a docker-compose-config factory function`
    );
  }
}

export class DCConfigFactoryNotRegisteredError extends Error {
  constructor(type: string) {
    super(
      `The service ${type} does not have declared any docker-compose-config factory function`
    );
  }
}

export async function autoregisterDCConfigFactory(
  repo: DockerComposeDefinitionRepository
) {
  const listRegistrableServices = Object.keys(dockerGeneratorsMap);
  for (let index = 0; index < listRegistrableServices.length; index++) {
    const type = listRegistrableServices[index];
    if (dockerGeneratorsMap[type]) {
      const factoryModulePath = join(
        "../../new/src",
        dockerGeneratorsMap[type]
      );
      const factoryFunction = (await import(factoryModulePath).then(
        (module) => module.default
      )) as DCConfigFactory;
      repo.register(type, factoryFunction);
    }
  }
}

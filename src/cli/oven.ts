#!/usr/bin/env node

import { ConfigurationHelper } from "../shared/helpers/ConfigurationHelper";
import { sync as spawnSync } from "cross-spawn";
import { join, resolve } from "path";
import { readFileSync, writeFileSync } from "fs";
import { safeLoad } from "js-yaml";
import { distinct, parseWithEnv } from "../shared/helpers/Utils";
import { CONFIG_FILE_NAME } from "../shared/constants";
import {
  autoregisterDCConfigFactory,
  DockerComposeDefinitionRepository,
  dockerComposesRegeneration,
} from "../shared/helpers/dockerComposeWriter";

let workspaceConfig: any = {};
try {
  workspaceConfig = require(resolve(join(process.cwd(), CONFIG_FILE_NAME)));
} catch (error) {
  console.error(
    "Unable to load wkspace.json, are you sure you are in the correct directory"
  );
  process.exit(1);
}

const envFilePath = resolve(join(process.cwd(), ".env.example"));

const config = new ConfigurationHelper(JSON.stringify(workspaceConfig));

const dockerFilesList = config.services.map(
  (service) => `-f ${service.dcompose}`
);

const customFlags = ["--target-prod", "--target-production"];

const main = async () => {
  const parsedWorkspaceConfEnv = Object.keys(workspaceConfig.env)
    .map((key) => {
      const envName = key;
      const envVal = parseWithEnv(workspaceConfig.env[key]);
      return { [envName]: envVal };
    })
    .reduce((acc, obj) => ({ ...acc, ...obj }), {});

  const env = {
    ...parsedWorkspaceConfEnv,
    ...process.env,
  };
  const repoDockerConfig = new DockerComposeDefinitionRepository();

  await autoregisterDCConfigFactory(repoDockerConfig);

  await dockerComposesRegeneration(config, repoDockerConfig, {
    env,
  });

  const isProdFlag = process.argv
    .slice(2, process.argv.length)
    .find(
      (a) =>
        a === "--target-prod" ||
        process.argv
          .slice(2, process.argv.length)
          .find((a) => a === "--target-production")
    );

  if (process.argv[2] === "env") {
    const envFile = config.services
      .map((service) => {
        const pathDc = join(process.cwd(), service.dcompose);
        const fileContent = readFileSync(pathDc).toString();
        const parsedDc = safeLoad(fileContent) as any;
        return parsedDc?.services[service.name]?.environment || [];
      })
      .reduce((acc, newEnvs) => [...acc, ...newEnvs], [])
      // Filter out all the fixed values
      .filter((env: string) => !!env.match(/\$\{/g));

    writeFileSync(
      envFilePath,
      distinct(["#Autogenerated, do not edit", ...envFile]).join("\n")
    );
    console.log(
      "Created an example.env file from the project services, do not change this file. Copy it in a .env file"
    );
    process.exit(0);
  }

  if (process.argv[2] === "host") {
    const hostFile = config.services
      .map((service) => {
        const pathDc = join(process.cwd(), service.dcompose);
        const fileContent = readFileSync(pathDc).toString();
        const parsedDc = safeLoad(fileContent) as any;
        return parsedDc?.services[service.name]?.environment || [];
      })
      .reduce((acc, newEnvs) => [...acc, ...newEnvs], [])
      // Filter out all the fixed values
      .filter((env: string) => !!env.match(/VIRTUAL_HOST=/g))
      .map((env) => /(VIRTUAL_HOST=)([a-z\.]*)/g.exec(env))
      .map((match) => (match[2] ? match[2] : null))
      .filter((a) => !!a)
      .map((domain) => `127.0.0.1 ${domain}`)
      .reduce(
        (acc, host) => `${acc}\n${host}`,
        "## Host File generated via kitchen-tools ##"
      );

    console.log(hostFile);
    process.exit(0);
  }

  if (isProdFlag) {
    process.env.BUILD_TARGET = "production";
  } else {
    // If there is no a prod flag and the variable is not set use development
    process.env.BUILD_TARGET = process.env.BUILD_TARGET || "development";
  }

  const sanitizeArgs = () => {
    return process.argv
      .slice(2, process.argv.length)
      .filter((arg) => !customFlags.find((flag) => arg === flag));
  };

  spawnSync(
    `docker-compose`,
    ["-f docker-compose.yaml", ...dockerFilesList, ...sanitizeArgs()],
    {
      cwd: process.cwd(),
      shell: true,
      env,
      stdio: [process.stdin, process.stdout, process.stderr],
    }
  );
};

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });

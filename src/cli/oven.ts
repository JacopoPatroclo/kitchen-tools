#!/usr/bin/env node

import { ConfigurationHelper } from "../shared/helpers/ConfigurationHelper";
import { sync as spawnSync } from "cross-spawn";
import { join, resolve } from "path";
import { readFileSync, writeFileSync } from "fs";
import { safeLoad } from "js-yaml";
import { distinct, parseWithEnv } from "../shared/helpers/Utils";
import { CONFIG_FILE_NAME } from "../shared/constants";

let workspaceConfig: any = {};
try {
  workspaceConfig = require(resolve(join(process.cwd(), CONFIG_FILE_NAME)));
} catch (error) {
  console.error(
    "Unable to load wkspace.json, are you sure you are in the correct directory"
  );
  process.exit(1);
}

const envFilePath = resolve(join(process.cwd(), ".env.example"));

const config = new ConfigurationHelper(JSON.stringify(workspaceConfig));

const dockerFilesList = config.services.map(
  (service) => `-f ${service.dcompose}`
);

const customFlags = ["--target-prod", "--target-production"];

const isProdFlag = process.argv
  .slice(2, process.argv.length)
  .find(
    (a) =>
      a === "--target-prod" ||
      process.argv
        .slice(2, process.argv.length)
        .find((a) => a === "--target-production")
  );

if (process.argv[2] === "env") {
  const envFile = config.services
    .map((service) => {
      const pathDc = join(process.cwd(), service.dcompose);
      const fileContent = readFileSync(pathDc).toString();
      const parsedDc = safeLoad(fileContent) as any;
      return parsedDc?.services[service.name]?.environment || [];
    })
    .reduce((acc, newEnvs) => [...acc, ...newEnvs], [])
    // Filter out all the fixed values
    .filter((env: string) => !!env.match(/\$\{/g));

  writeFileSync(
    envFilePath,
    distinct(["#Autogenerated, do not edit", ...envFile]).join("\n")
  );
  console.log(
    "Created an example.env file from the project services, do not change this file. Copy it in a .env file"
  );
  process.exit(0);
}

if (process.argv[2] === "host") {
  const hostFile = config.services
    .map((service) => {
      const pathDc = join(process.cwd(), service.dcompose);
      const fileContent = readFileSync(pathDc).toString();
      const parsedDc = safeLoad(fileContent) as any;
      return parsedDc?.services[service.name]?.environment || [];
    })
    .reduce((acc, newEnvs) => [...acc, ...newEnvs], [])
    // Filter out all the fixed values
    .filter((env: string) => !!env.match(/VIRTUAL_HOST=/g))
    .map((env) => /(VIRTUAL_HOST=)([a-z\.]*)/g.exec(env))
    .map((match) => (match[2] ? match[2] : null))
    .filter((a) => !!a)
    .map((domain) => `127.0.0.1 ${domain}`)
    .reduce(
      (acc, host) => `${acc}\n${host}`,
      "## Host File generated via kitchen-tools ##"
    );

  console.log(hostFile);
  process.exit(0);
}

const parsedWorkspaceConfEnv = Object.keys(workspaceConfig.env)
  .map((key) => {
    const envName = key;
    const envVal = parseWithEnv(workspaceConfig.env[key]);
    return { [envName]: envVal };
  })
  .reduce((acc, obj) => ({ ...acc, ...obj }), {});

if (isProdFlag) {
  process.env.BUILD_TARGET = "production";
} else {
  // If there is no a prod flag and the variable is not set use development
  process.env.BUILD_TARGET = process.env.BUILD_TARGET || "development";
}

const sanitizeArgs = () => {
  return process.argv
    .slice(2, process.argv.length)
    .filter((arg) => !customFlags.find((flag) => arg === flag));
};

spawnSync(
  `docker-compose`,
  ["-f docker-compose.yaml", ...dockerFilesList, ...sanitizeArgs()],
  {
    cwd: process.cwd(),
    shell: true,
    env: {
      ...parsedWorkspaceConfEnv,
      ...process.env,
    },
    stdio: [process.stdin, process.stdout, process.stderr],
  }
);
